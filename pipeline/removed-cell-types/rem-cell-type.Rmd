---
title: "Untitled"
output: html_document
date: "2022-09-10"
params:
  markers: "../../markers/CyTOF.yml"
  sce: "../../data/CyTOF/CyTOF-train.rds"
  needed_cells: "10"
  rem_cell_type: "IgD- IgMpos B cells"
  al_alg: ""
  strat: ""
  rand: ""
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../../')
suppressPackageStartupMessages({
  library(tidyverse)
  library(yaml)
  library(data.table)
  library(caret)
  library(SingleCellExperiment)
  library(fabricatr)
})
source("../../pipeline/whatsthatcell-helpers.R")
```

### Read in data
```{r}
#save.image('debug-rem-cell-type.Rdata')
cell_type_to_rem <- params$rem_cell_type
markers <- read_yaml(params$markers)

if(grepl('entropy', params$strat)){
    criterion <- 'entropy'
}else{
    criterion <- 'maxp'
}

sce <- readRDS(params$sce)
if(any(grepl("CD16_32", rownames(sce)))){
  rownames(sce)[grep("CD16_32", rownames(sce))] <- "CD16-32"
}

df_expression <- load_scs(sce)
df_expression$cell_type <- NA
df_expression$iteration <- NA
df_expression$gt_cell_type <- sce$CellType

### Create ground truth tibble
ground_truth <- tibble(cell_id = rownames(colData(sce)),
                       cell_type = sce$CellType)
```


### Rank cells
This is done is such a way to ensure a cell type of interest is not present in the initial traning set.
```{r}
selected_cells <- 0
needed_cells <- as.integer(params$needed_cells) # determines size of initial training set
discarded_cells <- c()

ranked_cells <- tibble(
  X1 = character(),
  cell_type = character()
)

# Copy the expression df so that cells can be removed during ranking
ranking_expression <- df_expression

# This loop iteratively runs until the determined size of the training set has been found
# Cells that are of the cell type that is not selected are then removed
while(selected_cells < needed_cells){
  left_to_rank_num <- needed_cells - selected_cells
  
  ranking_expression <- cell_ranking_wrapper(ranking_expression, 
                                             markers, 
                                             left_to_rank_num) |> 
    filter(cell_type != cell_type_to_rem  | is.na(cell_type))
  
  # Save selected cells minus cells to remove
  ranked_cells <- bind_rows(
    ranked_cells,
    filter(ranking_expression, !is.na(cell_type)) |> 
      select(X1, cell_type)
  )
  
  # Remove already selected cells so that new cells are selected with new ranking
  ranking_expression <- filter(ranking_expression, is.na(cell_type))
  
  # How many cells have been selected total?
  selected_cells <- nrow(ranked_cells)
}

# The cells that were selected
as.data.frame(ranked_cells)
```



### Set up active learning
```{r warning=F}
# First convert expression to PCA
# This uses the original df_expression containing all cells

# Remove genes with 0 expression
df_expression_non_zero <- select(df_expression, -where(is.character), -iteration, -cell_type)
df_expression_non_zero <- df_expression_non_zero[colSums(df_expression_non_zero) > 0]

df_PCA <- as.matrix(df_expression_non_zero) |> 
  prcomp(center = TRUE, scale. = TRUE)

df_PCA <- df_PCA$x |> 
  as.data.frame()

df_PCA <- bind_cols(
  tibble(X1 = df_expression$X1),
  df_PCA[,1:min(20, ncol(df_PCA))], 
  tibble(gt_cell_type = df_expression$gt_cell_type, # This is where the ground truth labels are stored
         iteration = df_expression$iteration)
)

missing_cell_type_PCA <- left_join(df_PCA, ranked_cells) # Adds the cell type labels

# Check input looks good
missing_cell_type_PCA |> 
  filter(!is.na(cell_type)) |> 
  as.data.frame()

# Function to run AL
rem_cell_type_AL_wrapper <- function(df, iter = 3){
  set.seed(1)
  entropies <- list()
  for(i in 1:iter){
    AL <- active_learning_wrapper(select(df, -gt_cell_type, -iteration), 
                                  params$al_alg, 
                                  params$strat, 
                                  i, 
                                  entropies, 
                                  as.numeric(params$rand),
                                  criterion)
    
    entropies[[length(entropies) + 1]] <- AL$criterion_table
    
    # What index do the selected cells correspond to?
    to_assign_index <- match(AL$new_cells, df$X1)
    
    # Get ground truth labels based on the index
    df$cell_type[to_assign_index] <- df$gt_cell_type[to_assign_index]
    df$iteration[to_assign_index] <- i
  }
  entropies
}

rem_entropies <- rem_cell_type_AL_wrapper(missing_cell_type_PCA)

missing_cell_type_uncertainty <- bind_rows(rem_entropies) |> 
  as_tibble() |> 
  mutate(comp = "missing cell types",
         num_missing_cells = 0) |> 
  left_join(select(df_expression, X1, gt_cell_type), by = c("cell_id" = "X1"))
```


## Repeat the same thing with different numbers of kept cells
```{r}
# Find the set of cells of the type that were removed above with the highest marker expression
missing_df_expression <- filter(df_expression, gt_cell_type == cell_type_to_rem)

# Create marker file with only markers for missing cell type
missing_cell_type_markers <- markers
marker_index_rem <- which(names(markers$cell_types) == cell_type_to_rem)
missing_cell_type_markers$cell_types <- markers$cell_types[marker_index_rem]

missing_cell_type_markers

# Which 3 cells of this type are selected by ranking?
missing_df_expression <- cell_ranking_wrapper(missing_df_expression, 
                                               missing_cell_type_markers, 
                                              3) |> 
  filter(!is.na(cell_type)) |> 
  select(X1, cell_type)


# Cells that have been selected
missing_df_expression

# Create three datasets with 1, 2 and 3 cells of the removed type
include_ranked_cell <- 
  lapply(1:3, function(x){
  bind_rows(
    slice_head(ranked_cells, n = (nrow(ranked_cells) - x)), # original dataset with cell type removed
    slice_head(missing_df_expression, n = x) # Dataset created with only said cell type
  ) |> mutate(num_missing_cells = x)
})

# Check out initial dataset
include_ranked_cell
```


### Run active learning with removed cells
```{r warning=F}
kept_cells_uncertainty <- lapply(include_ranked_cell, function(x){
  df_PCA <- left_join(df_PCA, 
                      select(x, -num_missing_cells), 
                      by = "X1")
  
  entr <- rem_cell_type_AL_wrapper(df_PCA)
  
  bind_rows(entr) |> 
    as_tibble() |> 
    mutate(comp = "kept cell types",
           num_missing_cells = unique(x$num_missing_cells))
}) |> bind_rows() |> 
  left_join(select(df_expression, X1, gt_cell_type), by = c("cell_id" = "X1"))

```


## Combine both entropy/maxp datasets and plot

Plot shows entropy or maxp (uncertainty) on the y axis for all cells in the training dataset
Facet = ground truth cell type 
Title = cell type that was not included in ranking
x = Number of cells annotated at this point (10 = 10 ranked cells, 20 = 10 ranked + 10 labeled w/ AL, etc.)
fill = How many cells of the removed type (see title) are in the initial 10 cells (if 0, this is the initial dataset with all cells of this type removed. If 1, one cell of this type in initial 10 cells, if 2, two cells of this type in initial 10 cells etc.)

I am expecting the Entropy to be higher for the removed cell type in the initial dataset that contains no cells of this type than the dataset that contains 1, 2, or 3 cells of this type. However, the opposite is the case.

```{r fig.width=8, fig.height=8}
bind_rows(missing_cell_type_uncertainty,
          kept_cells_uncertainty) |> 
  ggplot(aes(x = as.character(no_cells_annotated), y = criterion_val, fill = as.character(num_missing_cells))) + 
  geom_boxplot() + 
  labs(y = "Entropy", fill = "Number of cells of\nthe type removed\nin ranked dataset",
       title = paste("Cell type removed", cell_type_to_rem), 
       x = "Number of cells in traning set\n(starts out with 10 ranked cells, then 10 additional cells with each AL iteration)") +
  facet_wrap(~gt_cell_type) + 
  whatsthatcell_theme()
```



